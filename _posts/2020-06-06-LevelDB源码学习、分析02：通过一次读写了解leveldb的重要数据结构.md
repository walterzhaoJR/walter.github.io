# 2020-06-06 LevelDB源码学习、分析02：通过一次读写了解leveldb的数据存储

* 作为一个KV存储引擎，读写数据和存储数据当然是最最基本和重要的的操作。我们通过对读写操作的熟悉，来了解leveldb内部的一些实现。
* 我们知道leveldb的数据是存储在磁盘上的，并且使用了LSM-Tree（Log-Structured Merge-Tree）结构来实现。和随机对磁盘的读写相比，顺序对磁盘的读写拥有更高的性能，而LSM-Tree正是将对磁盘的随机写转化为顺序写，大大的提升了写入的速度。为了达到这个目的，LSM-Tree将索引树分成了一大一小两棵树（见下图），比较小的的常驻内存，比较大的就保存在磁盘上。这样他们两个共同维护着一个有序的KV空间。写入的数据会直接写到内存中的树，等待内存中的空间膨胀到一定大小，就会触发他的**Compaction**操作，本质就是一个归并排序，所以我们这里先叫这个过程为归并，后面再解释**Compaction**操作。而且归并操作的本质也是顺序写。另一方面，随着数据的写入，磁盘中的数据也会不断膨胀，这里为了优化读取数据的速度和避免每次归并操作数据量太大，leveldb将磁盘上的数据分成了很多文件，并且规定了若干文件会构成一个层（每一层的数据比上一层数据成倍数关系增长）的概念，所以当某一层的文件（也就是数据量）达到一定数量之后，就会触发向下一层的归并操作。这就是leveldb名字的由来。

<img src="/public/images/20200606/lsm_tree.png" style="zoom:70%;" />



## 0.一些基本概念

* 开始之前，先介绍一些leveldb的重要文件。

### 0.1 memtable

* 内存中的数据结构，最新的数据会写到这里，底层通过跳表实现。

### 0.2 log文件

* 写入memtable之前会先写入磁盘的log文件，log是顺序追加的方式写入（append），log存在的目的是用于宕机后数据的恢复。

### 0.3 immutable memtable

* 顾名思义，不变的memtable。用于当memtable的写入量到达阈值后，memtable就会变成immutable memtable，此时他只能读取，不能在接受数据写入，这个时候会有新的memtable生成用于接受新的写入请求。
* 后边做compaction的时候，会dump immutable到磁盘上必成sst文件。

### 0.4 sst文件：

* 全称：*Sorted String Table* ，就如名字所言，它是一个内部包含了任意长度、排好序的键值对<key,value>集合的文件。

* 在磁盘上用于存储数据的文件。
* 分为level 0到level n的若干层，每一层都包含了多个sst文件。
* 单层的sst文件总量随着层次的增加而成倍增加。
* level 0层的sst文件由immutable 直接 dump 而成，其他层的sst文件都是由上一层的文件和本层的文件进程归并操作而产生。
* sst文件在归并操作过程中通过顺序写入产生，生成后只读，仅仅在之后的归并操作中删除。

### 0.5 manifest文件

* manifest 文件中记录着sst文件处于的不同 level 信息，还记录着单个sst文件最大、最下key，以及一些其他的 leveldb 的元信息。
* 可以有多个。

### 0.6 current文件

* 由于 manifest 文件可以有多个，每当 leveldb 启动的时候要找到具体的 manifest 文件，所以 current 文件就记录了当前的 manifest 文件，使得这个过程编的很简单。

## 1.读写流程